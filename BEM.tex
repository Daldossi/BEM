Per risolvere il problema ai valori al bordo (BVP) nel caso del problema esterno di Dirichlet (EDP), lo riformulerò con un'equazione al bordo integrale (BIE) che mi permetterà di trovare un'approssimazione della soluzione tramite il metodo numerico degli elementi di contorno (BEM).

Siano $u^{\text{Inc}}$ l'onda incidente, $u^{\text{Scat}}$ l'onda riflessa e $u^{\text{Tot}} = u^{\text{Inc}} + u^{\text{Scat}} $ l'onda totale. Siano $\Omega_- \subset \R^2$ un dominio Lipschitz limitato, $\Omega_+ := \R^2 \backslash \overline{\Omega_-}$ e $\Gamma:= \partial \Omega_-$ (su questo bordo considererò solo condizioni \textit{sound-soft} \footnote{Il caso \textit{sound-soft} si verifica quando la pressione acustica sul bordo va a zero, $p_{\approx}=0$; quindi, imporre condizioni \textit{sound-soft} su $\Gamma$ significa che la traccia di Dirichlet dell'onda totale $u^{\text{Tot}}$ si azzera su $\Gamma$.}). Nel mio problema l'onda incidente $u^{\text{Inc}}$ su $\Omega_-$ rappresenta il dato, mentre l'onda riflessa $u^{\text{Scat}}$ è l'incognita che deve soddisfare l'equazione di Helmholtz sul dominio di propagazione $\Omega_+$ e le condizioni sound-soft $\gamma(u^{\text{Tot}}) = 0 $ su $\Gamma$. Inoltre, impongo che $u^{\text{Scat}}$ sia radiativa, cioè che soddisfi la condizione radiativa di Sommerfeld:
\begin{equation}
	|\partial_r u^{\text{Scat}} - iku^{\text{Scat}}| = o(r^{-\frac{1}{2}}) \qquad r \rightarrow \infty. 
\end{equation}
Allora il problema si può riscrivere:
\begin{equation}
	\text{trovare} \ u^{\text{Scat}} \in H^1_{\text{loc}} (\overline{\Omega_+}) \ \text{tale che} \ \begin{cases}
	\Delta u^{\text{Scat}} + k^2 u^{\text{Scat}} = 0 \quad \text{in} \ \Omega_+,\\
	\gamma^+(u^{\text{Scat}} + u^{\text{Inc}}) = 0 \quad \text{su} \ \Gamma,\\
	u^{\text{Scat}} \ \text{è radiativa}.
\end{cases}
\end{equation}
Nel caso 2-dimensionale, per un valore $\textbf{y} \in \R^2$ fissato, una soluzione radiativa fondamentale dell'equazione di Helmholtz è:
\begin{equation}
	\Phi_k(\textbf{x}, \textbf{y}) := \frac{i}{4} H^{(1)}_0 (k|\textbf{x}-\textbf{y}|), \quad \textbf{x} \ne \textbf{y} \in \R^2,
\end{equation}
dove $H^{(1)}_0$ è la funzione di Hankel di ordine $0$. Dal momento che ogni combinazione lineare delle componenti di $\Phi_k$, $\Phi_k(\cdot,\textbf{y}_j)$ soddisfa ancora l'equazione di Helmholtz in $\Omega_+$ ed è radiativa, allora posso anche considerare la seguente combinazione lineare continua delle soluzioni fondamentali
\begin{equation}
	(\mathcal{S} \psi)(\textbf{x}) := \int_{\Gamma} \Phi_k(\textbf{x},\textbf{y}) \psi(\textbf{y}) \mathrm{d}s(\textbf{y}) \quad \textbf{x} \in \Omega_+,
\end{equation}
che chiamerò \textit{single-leayer potential}. Inoltre definisco il \textit{single-layer operator} come
\begin{equation}
	(S \psi) (\textbf{x}) := \int_\Gamma \Psi_k(\textbf{x},\textbf{y}) \psi(\textbf{y}) \mathrm{d}s(\textbf{y}) \quad \textbf{x} \in \Gamma.
\end{equation}
Osservo poi che vale la relazione
\begin{equation}
	S \psi = \gamma^+ (\mathcal{S} \psi).
\end{equation}

L'idea del metodo degli elementi di contorno (BEM) consiste nello svolgimento dei seguenti passaggi:
\begin{enumerate}
	\item scegliere uno spazio $V_N \subset H^{-\frac{1}{2}}(\Gamma)$ $N$-dimensionale e le sue funzioni base;
	\item partizionare la curva $\Gamma$ in una mesh $\mathcal{T}_N(\Gamma)$ di $N$ segmenti $K_1,\dots,K_N \subset \Gamma$;
	\item trovare $\psi_N \in V_N$ definita su $\Gamma$ tale che approssimi la soluzione dell'equazione integrale al contorno (BIE)
	\begin{equation} \label{BIE}
		S\psi = g_D \quad \text{su} \ \Gamma,
	\end{equation}
	dove $g_D$ è il dato di Dirichlet per il (EDP) e $\psi$ è detta densità;
	\item ricavare $u$ tramite la formula di rappresentazione
	\begin{equation}
		u = \mathcal{S} \psi \quad \text{in} \ \Omega_{+}.
	\end{equation}
\end{enumerate}
Si può affermare che la $u$ così identificata risulta essere una soluzione radiativa di Helmholtz in $\Omega_{+}$ con $\gamma^+ u = \gamma^+ \mathcal{S} \psi = S\psi = g_D$, quindi $u$ è la soluzione del problema di Dirichlet esterno (EDP) che si cercava.



\subsection{Definizione di $V_N$ e partizionamento di $\Gamma$}
Scelgo $V_N$ come lo spazio delle funzioni costanti a tratti su $\mathcal{T}_N(\Gamma)$. Prendo come base di $V_N$ $\{\varphi_j\}_{j=1}^N$, dove, per ogni $j$, la funzione di base $\varphi_j$ è definita nel seguente modo 
\[ \varphi_j(\textbf{x}) := \begin{cases}
	1 \ \text{se} \ \textbf{x}\in K_j \\ 0 \ \text{se} \ \textbf{x}\in \Gamma \backslash K_j
\end{cases}. \]
Per partizionare $\Gamma$ implemento i seguenti due metodi.
\begin{enumerate}
	\item \textbf{Uniforme.} Nella funzione funzione \verb|BE_u.m| (\textit{BoundaryElements$\_$uniform}) sono dati in input: \verb|ver| vettore in cui ogni riga rappresenta un vertice (come valore complesso) del poligono che si sta studiando (in senso antiorario), \verb|h| ampiezza massima di ogni elemento della discretizzazione e \verb|i_pol| matrice a due colonne in cui la riga j-esima indica la posizione (indice) nel vettore \verb|ver| del vertice di inizio e quella del vertice di fine del poligono corrispondente alla riga. Ci sono due output: \verb|PT| è il vettore contenente tutte le coordinate dei punti della discretizzazione, \verb|i_POL| invece è una matrice a due colonne in cui ogni riga indica il vertice di inizio e quello di fine di ogni elemento creato. L'algoritmo consiste nel trattare un lato $l_i$ del poligono alla volta e decidere il suo numero di elementi $n_i$ come l'approssimazione per eccesso di $length(l_i) / h$. Si veda \href{https://github.com/Daldossi/BEM/blob/main/BE_u.m}{BEu.m}.
	\item \textbf{Adattivo.} La funzione \verb|BE_a| (\textit{BoundaryElements$\_$adaptive}) ha output è analogo a quello del metodo precedente; l'input richiede ancora \verb|ver| e \verb|i_pol| che mantengono il ruolo di prima, \verb|h| è l'ampiezza che determinerà il numero di elementi $n$ per lato e \verb|z| è il parametro che rappresenta la velocità con cui i punti da individuare verranno addensati verso un'estremità. L'idea dell'algoritmo è la seguente: si considera un lato $l_i$ alla volta, si prende $n_i := length(l_i) / h$ e sull'intervallo $[0,1]$ si scelgono $n_i$ punti con la formula $\{ \left(\frac{i}{n_i+1}\right)^z \}_{i=1}^{n_i}$ (più $z$ è grande, più la discretizzazione concentrerà gli elementi verso zero); questi poi si trasferiscono sugli intervalli che definiscono le due metà del lato $l_i$. Si vedano \href{https://github.com/Daldossi/BEM/blob/main/BE_a.m}{BEa.m} e \href{https://github.com/Daldossi/BEM/blob/main/adaptive.m}{adaptive.m}.
\end{enumerate}
Osservo che, nel caso in cui $\Gamma$ non sia poligonale ma abbia una forma circolare, allora l'informazione geometrica necessaria per descriverlo deve comprendere il centro e il raggio del cerchio (o eventualmente dei cerchi), non ci saranno più vertici. Per questo motivo è stata creata la funzione \verb|BE_u_c| (\textit{BoundaryElements$\_$uniform$\_$circular}) in cui il vettore \verb|ver| in input contiene appunto le informazioni del centro e del raggio che descrive $\Gamma$, mentre \verb|h| e \verb|i_pol| mantengono i loro significati di prima. Con un procedimento analogo a quello svolto per la discretizzazione adattiva, i punti sulla mesh circolare vengono individuati tramite una parametrizzazione di quelli sull'intervallo $[0,1]$.Si veda \href{https://github.com/Daldossi/BEM/blob/main/BE_u_c.m}{BEuc.m}. \\
Nelle figure \ref{MeshT}-\ref{MeshC} riporto $5$ diversi esempi di dominio con la loro rispettiva discretizzazione.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{MeshTriangolo}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/BoundaryElements_test.m}{BoundaryElementsTest.m}.] Confronto tra i metodi di discretizzazione per $h= 0.1$ e $z= 2$ sul triangolo di vertici $(0;0)$, $(1;0)$ e $(0;1)$.}
	\label{MeshT}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{MeshQuadrato}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/BoundaryElements_test.m}{BoundaryElementsTest.m}.] Confronto tra i metodi di discretizzazione per $h= 0.1$ e $z= 2$ sul quadrato di centro $(0.5;0.5)$ e lato $1$.}
	\label{MeshQ}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{MeshU}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/BoundaryElements_test.m}{BoundaryElementsTest.m}.] Confronto tra i metodi di discretizzazione per $h= 0.1$ e $z= 2$ sulla "U rovesciata".}
	\label{MeshU}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{MeshFenditura}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/BoundaryElements_test.m}{BoundaryElementsTest.m}.] Confronto tra i metodi di discretizzazione per $h= 0.1$ e $z= 2$ sulla fenditura ampia $0.2$ e muro spesso $0.1$.}
	\label{MeshF}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{MeshCerchio}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/BoundaryElements_test.m}{BoundaryElementsTest.m}.] Confronto tra i metodi di discretizzazione per $h= 0.1$ sul cerchio di centro $(0.5;0.5)$ e raggio $0.25$.}
	\label{MeshC}
\end{figure}



\subsection{Approssimazione della soluzione $\psi$ di (BIE)}
Per risolvere \eqref{BIE}, quindi trovare $\psi_N \in V_N$, si possono implementare due diversi metodi:
\begin{itemize}
	\item \textbf{Collocazione-BEM:} si scelgono $N$ punti $x_1,\dots,x_N \in \Gamma$ e si cerca
	\begin{equation}
		\psi_N\in V_N \ \text{tale che} \ (S\psi_N)(\textbf{x}_j) = g_D(\textbf{x}_j), \quad j= 1,\dots,N;
	\end{equation}
	\item \textbf{Galerkin-BEM:} si cerca
	\begin{multline} \label{Galerkin}
		\psi_N \in V_N \ \text{tale che} \\ \mathcal{A}(\psi_N,\xi_N) = \int_\Gamma (S\psi_N)\overline{\xi_N} \mathrm{d}s = \int_\Gamma g_D\overline{\xi_N} \mathrm{d}s = \mathcal{F}(\xi_N), \quad \forall \xi_N \in V_N.
	\end{multline}
\end{itemize}
Osservo che espandendo la soluzione approssimata $\psi_N$ in coordinate ho
\[ \psi_N= \sum_{j=1}^N \Psi_j \varphi_j, \]
dove $\Psi_j = (\pmb{\Psi})_j$ è il $j$-esimo elemento del vettore $\bm{\Psi} \in \C^n$; cioè, 
\[ \psi_N(\textbf{x}) = \Psi_j \ \text{se} \ \textbf{x} \in K_j. \]



\subsubsection{Collocazione-BEM}
Presi lo spazio $N$-dimensionale $V_N$ e la sua base $\{\varphi_j\}_{j=1}^N$ definiti come sopra, il metodo di collocazione prevede la definizione di $N$ nodi $\textbf{x}_j$ tali che $\textbf{x}_j \in K_j \ \forall j = 1,\dots,N$ in cui collochiamo l'equazione differenziale. In questo modo si risolve il sistema lineare $\underline{\underline{\textbf{A}}}^{\text{col}} \bm{\Psi} = \textbf{F}^{\text{col}}$, dove
	\begin{align}
		&A_{j,m}^{\text{col}} := (S \varphi_m)(\textbf{x}_j) = \int_\Gamma \Phi_k(\textbf{x}_j,\textbf{y}) \varphi_m(\textbf{y}) \mathrm{d}s(\textbf{y}) = \int_{K_m} \Phi_k(\textbf{x}_j,\textbf{y}) \mathrm{d}s(\textbf{y}), \label{A^col} \\
		&F_j^{\text{col}} := g_D(\textbf{x}_j). \label{F^col}
	\end{align}
%Preciso che, per poter calcolare il vettore di destra $\textbf{F}^{\text{col}}$, abbiamo bisogno che $g_D \in C^0(\Gamma)$. \\
Ora si supponga che $\Omega_{-}$ sia un poligono convesso e che ogni elemento della mesh sia un segmento dritto. Per $j=1,\dots,N$, l'elemento $K_j$ ha estremità $\textbf{p}_j$ e $\textbf{p}_{j+1}$, lunghezza $h_j := |\textbf{p}_{j+1}-\textbf{p}_{j}|$ ed è parametrizzato da $\textbf{X}_j:(0,h_j) \rightarrow K_j, \ \textbf{X}_j(s) := \textbf{p}_j + s\bm{\tau}_j$, dove $\bm{\tau}_j := \frac{\textbf{p}_{j+1} - \textbf{p}_j}{|\textbf{p}_{j+1} - \textbf{p}_j|}$ è il vettore tangente unitario a $K_j$.
Le equazioni \eqref{A^col} e \eqref{F^col} che definiscono il sistema sono svolte con formule di quadratura:
\begin{align}
	&A_{j,m}^{\text{col}} = \frac{i}{4} \int_0^{h_m} H^{(1)}_0(k |\textbf{p}_m + s \bm{\tau}_m - \textbf{x}_j|) \mathrm{d}s(\textbf{y}) = \frac{i}{4} h_m \int_0^1 H^{(1)}_0(k |\textbf{p}_m + h_m \bm{\tau}_m t - \textbf{x}_j|) \mathrm{d}t, \\&
	F_j^{\text{col}} = g_D(\textbf{x}_j).
\end{align}
Dal momento che l'integrale che si ottiene per $m=j$ è singolare, allora:
\begin{equation}
	A_{j,j}^{\text{col}} = \int_{K_j} \Phi_k(\textbf{x}_j,\textbf{y}) \mathrm{d}s(\textbf{y}) = \frac{i}{2} \int_0^{\frac{h_j}{2}} H^{(1)}_0(ks) \mathrm{d}s = \frac{i h_j}{4} \int_0^1 H^{(1)}_0 \left( k \frac{h_j}{2} t \right) \mathrm{d}t.
\end{equation}
%Per questa ragione scegliere i punti medi degli elementi come nodi di collocazione è un'ottima scelta:
%\begin{equation}
%	\textbf{x}_j = \frac{1}{2}(\textbf{p}_j + \textbf{p}_{j+1}).
%\end{equation}

Si veda il codice \href{https://github.com/Daldossi/BEM/blob/main/BEM_col.m}{BEMcol.m}.
Qui ho preso in input: \verb|PT| è il vettore tale che ogni entrata è un valore complesso che indica le coordinate di un punto della mesh, \verb|POL| è una matrice a due colonne tale che ogni riga indica gli indici sul vettore \verb|PT| del vertice di inizio e di quello di fine del poligono corrispondente a quella riga, \verb|k| è il parametro dell'equazione di Helmholtz, \verb|g_D| è la funzione dato sul bordo $\Gamma$ e prende in input un valore complesso \footnote{In questa relazione userò sempre le onde piane, quindi $e^{ik\textbf{x}\cdot\textbf{d}}$, con $\textbf{d}$ direzione dell'onda. Con piccoli adattamenti ai codici, si potrebbe sostituire con una funzione di Herglotz $\int_0^{2\pi}g(\phi)e^{ik(x_1\cos\phi+x_2\sin\phi)}\mathrm{d}\phi$, dove $g\in L^2(0,\pi)$ è il kernel.}, \verb|x_val| è il dominio riportato in numeri complessi sui cui si valuta l'approssimazione dell'onda scatterata (si veda \S \ref{ScatteredWave}), \verb|flag| è una stringa che indica se svolgere (\verb|'se'|) o no (\verb|'no'|) la \textit{singularity extraction} (si veda \S \ref{SingularityExtraction}). L'output: \verb|u_scat| è l'approssimazione dell'onda scatterata calcolata tramite il metodo di collocazione.


\subsubsection{Galerkin-BEM}
% Per problemi la cui soluzione non è differenziabile due volte con continuità, il metodo di collocazione risulta impossibile da utilizzare, quindi si può far ricorso al metodo di Galerkin.
Il metodo di Galerkin si presenta come la “restrizione” del problema variazionale
\begin{equation}
	\mathcal{A}(\psi,\xi) := \left\langle S\psi,\xi \right\rangle_{H^{\frac{1}{2}}(\Gamma) \times H^{-\frac{1}{2}}(\Gamma)} = \left\langle g_D, \xi \right\rangle_{H^{\frac{1}{2}}(\Gamma) \times H^{-\frac{1}{2}}(\Gamma)} =: \mathcal{F}(\xi) \quad \forall \xi \in H^{-\frac{1}{2}}(\Gamma).
\end{equation}
a un sottospazio finito dimensionale $V_N$ con base $\{\varphi_j\}_{j=1}^N$, dove $V_N$ e $\{\varphi_j\}_{j=1}^N$ sono presi come sopra. Quindi l'equazione \eqref{Galerkin} che chiedo per ogni elemento di $V_N$ si riduce a N equazioni lineari che creano il sistema lineare $\underline{\underline{\textbf{A}}}^{\text{Gal}} \bm{\Psi} = \textbf{F}^{\text{Gal}}$ in cui
\begin{align}
	&A_{j,m}^{\text{Gal}} := \mathcal{A}(\varphi_m,\varphi_j) = \left\langle S\varphi_m, \varphi_j \right\rangle _\Gamma = \int_\Gamma \int_\Gamma \Phi_k(\textbf{x},\textbf{y}) \varphi_m(\textbf{y}) \overline{\varphi_j}(\textbf{x}) \mathrm{d}s(\textbf{x}), \\
	&F_j^{\text{Gal}} := \mathcal{F}(\varphi_j) = \left\langle g_D, \varphi_j \right\rangle _\Gamma = \int_\Gamma g_D(\textbf{x}) \overline{\varphi_j}(\textbf{x}) \mathrm{d}s(\textbf{x}).
\end{align}
%Questa restrizione agisce in due modi: (1) cerchiamo una soluzione discreta solo in Vh, (2) richiediamo che A(uh, wh) = F(wh) solo per funzioni test wh in V
Similmente a quanto svolto per il metodo di collocazione si ricavano le formule
\begin{equation}
	F_j^{\text{Gal}} = \int_{K_j} g_D(x) \mathrm{d}s(x) = h_j \int_0^1 g_D(\textbf{p}_j + h_j\bm{\tau}_jt) \mathrm{d}t;
\end{equation}
\begin{equation}
	A_{j,m}^{\text{Gal}} = \int_{K_j}\int_{K_m} \Phi_k(\textbf{x},\textbf{y}) \mathrm{d}s(x) \mathrm{d}s(y) = \frac{i}{4} h_j h_m \int_0^1 \int_0^1 H^{(1)}_0 (k |\textbf{p}_j + h_j \bm{\tau}_m \eta|) \mathrm{d}\xi\mathrm{d}\eta.
\end{equation}
In questo caso ci sono più situazioni che portano a singolarità: oltre che lungo la diagonale principale $j=m$, anche lungo quella secondaria. Infatti i problemi sono generati anche dal fatto che due elementi possono condividere un estremo. Quindi gli integrali diventano:
\begin{multline}
	A_{j,j}^{\text{Gal}} = i \int_{0}^{\frac{h_j}{\sqrt{2}}} \left( \frac{h_j}{\sqrt{2}} - \xi \right) H^{(1)}_0 (\sqrt{2} k \xi) \mathrm{d}\xi = i \left( \frac{h_j}{\sqrt{2}} \right) ^2 \int_0^1 (1-\eta) H^{(1)}_0 (k \frac{h_j}{\sqrt{2}} \eta) \mathrm{d}\eta \\
	\text{con} \ \xi = \frac{s-t}{\sqrt{2}} \ \text{e} \ \eta = \frac{s+t}{\sqrt{2}},
\end{multline}
\begin{equation}
	A_{j,j+1}^{\text{Gal}} = \int_0^{h_j} \left( \int_0^{h_{j+1}} \frac{1}{4} H^{(1)}_0 (k |h_j - s + t|)\mathrm{d}t \right) \mathrm{d}s,
\end{equation}
da risolvere ancora una volta con la regola di Gauss.


Si veda il codice \href{https://github.com/Daldossi/BEM/blob/main/BEM_gal.m}{BEMgal.m}.
In questo caso i valori richiesti in input sono gli stessi della funzione \verb|BEM_gal.m|. L'output \verb|u_scat| è l'approssimazione dell'onda scatterata calcolata tramite il metodo di Galerkin.


\subsubsection{Singularity extraction} \label{SingularityExtraction}
Un metodo alternativo per risolvere il problema della singolarità negli integrali è la tecnica chiamata \textit{singularity extraction} che sfrutta la seguente formula asintotica per $z \searrow 0$
\begin{equation}
	H_0^{(1)}(z) = i\frac{2}{\pi}\ln z + 1 + i \frac{2}{\pi} (\gamma-2) + O(z^2),
\end{equation}
con $\gamma \approx 0.57721$ costante di Eulero. Infatti, dato che per gli elementi sulla diagonale si ha $|x-y| \rightarrow 0$, allora lì si può usare che
\begin{equation}
	\Phi_k(x,y) = -\frac{1}{2\pi}\ln|x-y| + \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} + O(|x-y|^2\ln|x-y|).
\end{equation}
Quindi le formule per ottenere $A_{j,j}^{\text{Col}}$ e $A_{j,j}^{\text{Gal}}$ si possono scrivere anche sfruttando la \textit{singularity extraction}, ottenendo:
\begin{align*}
	A_{j,j}^{\text{Col}} &= \int_{K_j} \phi_k(x_j,y) \mathrm{d}s(y) = 2 \int_{0}^{\frac{h_j}{2}} \frac{i}{4} H_0^{(1)} (ks)\mathrm{d}s = \\
	&\approx 2 \int_{0}^{\frac{h_j}{2}} \left( -\frac{1}{2\pi} \ln s + \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} \right) \mathrm{d}s = \\
	&= 2 \left[ \left( \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} \right) \frac{h_j}{2} - \frac{1}{2\pi} \int_{0}^{\frac{h_j}{2}} \ln s \mathrm{d}s \right] = \\
	&\overset{(1)}{=} 2 \frac{h_j}{2} \left( \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} - \frac{1}{2\pi}\ln\frac{h_j}{2} + \frac{1}{2\pi} \right) = \\
	&= \frac{h_j}{2\pi} \left( \frac{\pi i}{2} - \ln\frac{k}{2} - \gamma - \ln\frac{h_j}{2} + 1 \right);
\end{align*}
\begin{align*}
	A_{j,j}^{\text{Gal}} &= i \int_0^{\frac{h_j}{\sqrt{2}}} \left( \frac{h_j}{\sqrt{2}} - \xi \right) H_0^{(1)} (\sqrt{2}k\xi) \mathrm{d}\xi = \\
	&\approx 4 \int_0^{\frac{h_j}{\sqrt{2}}} \left( \frac{h_j}{\sqrt{2}} - \xi \right) \left( -\frac{1}{2\pi}\ln(\sqrt{2}\xi) + \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} \right) \mathrm{d}\xi = \\
	&=4 \left( \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} \right) \int_0^{\frac{h_j}{\sqrt{2}}} \left( \frac{h_j}{\sqrt{2}} - \xi \right) \mathrm{d}\xi - \frac{4}{2\pi} \int_0^{\frac{h_j}{\sqrt{2}}} \left( \frac{h_j}{\sqrt{2}} - \xi \right) \ln(\sqrt{2}\xi) \mathrm{d}\xi = \\
	&= \frac{h_j^2}{4} 4\left( \frac{i}{4} -\frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} \right) - \frac{4}{2\pi} \frac{h_j}{\sqrt{2}} \int_0^{\frac{h_j}{\sqrt{2}}} \ln(\sqrt{2}\xi) \mathrm{d}\xi + \frac{4}{2\pi} \int_0^{\frac{h_j}{\sqrt{2}}} \xi\ln(\sqrt{2}\xi) \mathrm{d}\xi = \\
	&\overset{(2)}{=} h_j^2 \left[ \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} -\frac{1}{2\pi} \left( 2\ln\frac{h_j}{\sqrt{2}} - 2 + \ln2 \right) \right] + \frac{4}{2\pi} \int_0^{\frac{h_j}{\sqrt{2}}} \xi\ln(\sqrt{2}\xi) \mathrm{d}\xi= \\
	&\overset{(3)}{=} h_j^2 \left[ \frac{i}{4} - \frac{1}{2\pi}\ln\frac{k}{2} - \frac{\gamma}{2\pi} -\frac{1}{2\pi} \left( 2\ln\frac{h_j}{\sqrt{2}} - 2 + \ln2 \right) + \frac{1}{4\pi} \left( 2 \ln\frac{h_j}{\sqrt{2}} - 1 + \ln2 \right) \right] = \\
	&= \frac{h_j^2}{2\pi} \left( \frac{i\pi}{2} - \ln\frac{k}{2} - \gamma - 2\ln\frac{h_j}{\sqrt{2}} + 2 - \ln2 + \ln\frac{h_j}{\sqrt{2}} - \frac{1}{2} + \frac{1}{2}\ln2 \right) = \\
	&= \frac{h_j^2}{2\pi} \left( \frac{i\pi}{2} - \ln\frac{k}{2} - \gamma - \ln\frac{h_j}{\sqrt{2}} - \frac{1}{2}\ln2 + \frac{3}{2} \right) = \\
	&= \frac{h_j^2}{2\pi} \left( \frac{i\pi}{2} - \ln\frac{k}{2} - \gamma - \ln{h_j} + \frac{3}{2} \right).
\end{align*}
In $(1)$ ho usato la regola generale $\int_0^a \ln x = a(\ln a - 1)$; in $(2)$ invece $\int_0^a \ln(\sqrt{2}\xi) \mathrm{d}\xi = \frac{a}{2} (2\ln a -2 +\ln2)$ e in $(4)$ $\int_0^a \xi\ln(\sqrt{2}\xi) \mathrm{d}\xi = \frac{a^2}{4} (2\ln a -1 + \ln2)$. 

Si vedano ancora i codici \verb|BEM_gal.m| e \verb|BEM_col.m|, guardando il caso di \verb|flag = 'se'|.



\subsection{Formula di rappresentazione} \label{ScatteredWave}
Dopo aver ottenuto il valore di $\bm{\Psi}$ si ricava l'approssimazione della soluzione $u$:
\begin{equation}
	u_N(\textbf{x}) := (\mathcal{S}\psi_N)(\textbf{x}) = \int_\Gamma \Phi_k(\textbf{x},\textbf{y}) \psi_N(\textbf{y}) \mathrm{d}s(\textbf{y}) = \sum_{j=1}^N \Psi_j \int_{K_j} \Phi_k(\textbf{x},\textbf{y}) \mathrm{d}s(\textbf{y}), \qquad \textbf{x} \in \Omega_+.
\end{equation}
Tramite le formule di quadratura si giunge all'espressione seguente
\begin{align*}
	u^{\text{Scat}}_N(\textbf{x}) &= (\mathcal{S}\psi)(\textbf{x}) = \left(\mathcal{S} \sum_{j=1}^n \psi_j \varphi_j \right) (\textbf{x}) = \int_{\Gamma} \left( \sum_{j=1}^n \psi_j \varphi_j (\textbf{y}) \right) \phi_k(\textbf{x},\textbf{y}) \mathrm{d}s(\textbf{y}) = \\
	&= \sum_{j=1}^n \psi_j \int_{K_j} \phi_k(\textbf{x},\textbf{y}) \mathrm{d}s(\textbf{y}) = \\
	&= \frac{i}{4} \sum_{j=1}^n \psi_j \int_0^{h_j} H_0^{(1)}(k|\textbf{p}_j + h_j\bm{\tau}_jt -\textbf{x}|) \mathrm{d}s = \\
	&= \frac{i}{4} \sum_{j=1}^n \psi_j h_j \int_0^1 H^{(1)}_0 (k|\textbf{p}_j + h_j\bm{\tau}_jt -\textbf{x}|) \mathrm{d}t = \\
	&= \frac{i}{4} \int_0^1 \sum_{j=1}^n \psi_j h_j H_0^{(1)} (k|\textbf{p}_j + h_j\bm{\tau}_jt -\textbf{x}|) \mathrm{d}t.
\end{align*}

Per il calcolo di $u_N$ ho implementato la funzione \verb|ScatteredWave.m| in cui in input sono richiesti: \verb|PT| vettore in cui ogni entrata è un valore complesso che indica le coordinate di un punto della mesh, \verb|POL| matrice a due colonne tale che ogni riga indica gli indici sul vettore \verb|PT| del vertice di inizio e di quello di fine del poligono corrispondente a quella riga, \verb|x_val| dominio riportato in numeri complessi sui cui si valuta l'approssimazione dell'onda scatterata, \verb|psi| vettore dei coefficienti che rappresenta la densità, \verb|k| coefficiente dell'equazione di Hemlholtz. L'output: \verb|u_scat| è l'approssimazione dell'onda scatterata. Si veda il codice \href{https://github.com/Daldossi/BEM/blob/main/ScatteredWave.m}{ScatteredWave.m}.

Nelle figure \ref{quadrato}-\ref{2triangoli} sono riportati gli scatter delle onde nel caso di divrsi domini.

\begin{figure}[h!]
	\centering
	\includegraphics[width=1\textwidth]{quadrato_inc}
	\includegraphics[width=1\textwidth]{quadrato_scat}
	\includegraphics[width=1\textwidth]{quadrato_tot}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/solution.m}{solution.m}.] Plot su $[-1.5,1.5]^2$ di un'onda piana con direzione $\alpha=-\frac{\pi}{4}$ e parametro $k=20$ su una mesh di $150$ punti con un vincolo quadrato. Ho usato il metodo di collocazione senza \textit{singularity extraction} con discretizzazione uniforme e prendendo l'ampiezza $h=0.1$.}
	\label{quadrato}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{triangolo_inc}
	\includegraphics[width=1\textwidth]{triangolo_scat}
	\includegraphics[width=1\textwidth]{triangolo_tot}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/solution.m}{solution.m}.] Plot su $[-1,2]^2$ di un'onda piana con direzione $\alpha=\frac{\pi}{3}$ e parametro $k=20$ su una mesh di $150$ punti con un vincolo triangolare. Ho usato il metodo di collocazione senza \textit{singularity extraction} con discretizzazione uniforme e prendendo l'ampiezza $h=0.1$.}
	\label{triangolo}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{U_inc}
	\includegraphics[width=1\textwidth]{U_scat}
	\includegraphics[width=1\textwidth]{U_tot}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/solution.m}{solution.m}.] Plot su $[-1,2]^2$ di un'onda piana con direzione $\alpha=\frac{\pi}{3}$ e parametro $k=20$ su una mesh di $150$ punti con un vincolo a "U" rovesciata. Ho usato il metodo di collocazione senza \textit{singularity extraction} con discretizzazione uniforme e prendendo l'ampiezza $h=0.1$.}
	\label{U}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{fenditura_inc}
	\includegraphics[width=1\textwidth]{fenditura_scat}
	\includegraphics[width=1\textwidth]{fenditura_tot}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/solution.m}{solution.m}.] Plot su $[-1,2]^2$ di un'onda piana con direzione $\alpha=0$ e parametro $k=20$ su una mesh di $150$ punti con un vincolo con una fenditura. Ho usato il metodo di collocazione senza \textit{singularity extraction} con discretizzazione uniforme e prendendo l'ampiezza $h=0.1$.}
	\label{fenditura}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{stella_inc}
	\includegraphics[width=1\textwidth]{stella_scat}
	\includegraphics[width=1\textwidth]{stella_tot}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/solution.m}{solution.m}.] Plot su $[-1,2]^2$ di un'onda piana con direzione $\alpha=\frac{\pi}{3}$ e parametro $k=20$ su una mesh di $150$ punti con un vincolo a forma di stella a quattro punte. Ho usato il metodo di collocazione senza \textit{singularity extraction} con discretizzazione uniforme e prendendo l'ampiezza $h=0.001$.}
	\label{stella}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{DueTriangoli_inc}
	\includegraphics[width=1\textwidth]{DueTriangoli_scat}
	\includegraphics[width=1\textwidth]{DueTriangoli_tot}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/solution.m}{solution.m}.] Plot su $[-1,2]^2$ di un'onda piana con direzione $\alpha=\frac{\pi}{3}$ e parametro $k=20$ su una mesh di $150$ punti con un vincolo a forma di due triangoli. Ho usato il metodo di collocazione senza \textit{singularity extraction} con discretizzazione uniforme e prendendo l'ampiezza $h=0.1$.}
	\label{2triangoli}
\end{figure}



\subsection{Convergenza}
Al termine ho verificato la convergenza. Al variare dell'ampiezza della mesh $h=2^{-i}$ con $i=4,\dots,10$ ho stimato l'errore in norma $L^2$ prendendo come soluzione di riferimento dell'onda totale quella descritta da \verb|MPSpackBenchmarkSquareScatt.m| e ho considerato solo la parte esterna al cerchio unitario. Lo studio è stato svolto sia utilizzando collocazione che Galerkin, confrontando, sia nel caso di mesh adattiva che uniforme, la soluzione ricavata con la \textit{singularity extraction} con quella ricavata senza.\\
Dalla figura \ref{fig_errore1} si evince che la discretizzazione adattiva è migliore sia col metodo di collocazione che con quello di Galerkin.

Il codice \href{https://github.com/Daldossi/BEM/blob/main/Error.m}{Error.m} prende in input: \verb|flag1| è una stringa che indica se approssimare l'onda scatterata con il metodo di collocazione (\verb|'col'|) oppure con Galerkin (\verb|'gal'|), \verb|flag2| è un'altra stringa che dice se usare la \textit{singularity extraction} (\verb|'se'|) oppure no (\verb|'no'|), \verb|PT| è il vettore in cui ogni entrata è un valore complesso che indica le coordinate di un punto della mesh, \verb|POL| è una matrice a due colonne tale che ogni riga indica gli indici sul vettore \verb|PT| del vertice di inizio e di quello di fine del poligono corrispondente a quella riga, \verb|k| è il coefficiente dell'equazione di Hemlholtz, \verb|PWave| è una funzione a una variabile complessa che descrive il dato sul bordo $\Gamma$, \verb|Omega| sono i punti (descritti come numeri complessi) su cui si valuta l'approssimazione dell'onda scatterata, \verb|u| è l'onda scatterata e totale di riferimento, \verb|ui| è l'onda incidente di riferimento, \verb|X| l'ascissa della griglia di valutazione, \verb|Y| l'ordinata della griglia di valutazione, \verb|R| è il raggio del cerchio al cui esterno si calcola l'errore. L'output è il valore \verb|E| dell'errore in $L^2$ tra l'onda approssimata e quella di riferimento. 

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{errore1}
	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/Error_test.m}{ERRORtest.m}] Errore nel caso di dominio quadrato, per $h=2^{-4},\dots,2^{-10}$, con dimensione del sistema pari a $150$. }
	\label{fig_errore1}
\end{figure}

%Come ulteriore test, ho calcolato l'errore nel caso di un dominio con più spigoli per osservare meglio la maggior efficacia del metodo adattivo rispetto a quello uniforme in queste situazioni. Ho preso come riferimento l'onda calcolata con $h=2^{-11}$.

%\begin{figure}
%	\centering
%	\includegraphics[width=1\textwidth]{errore2}
%	\caption{[script: \href{https://github.com/Daldossi/BEM/blob/main/Error_test.m}{ERRORtest.m}] }
%	\label{fig_errore2}
%\end{figure}